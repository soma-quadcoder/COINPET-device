#include <avr/io.h>
#include "oled.h"


unsigned char font_goal[6][16] =
{
    {0xFF,0xFF,0xFF,0x07,0x07,0x07,0x07,0x07,0xFF,0xFF,0xFF,0xE0,0xE0,0xE0,0xE0,0xE0}, /*"["*/
    {0x3f,0x3f,0x33,0xb3,0xb3,0x33,0x3f,0x3f,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0xfb,0xfb}, /*"목"*/
    {0xc7,0xff,0xff,0xc7,0xc7,0xff,0xff,0xc7,0xe1,0xfd,0xfd,0xe1,0xe1,0xfd,0xfd,0xe1}, /*"표"*/
    {0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xDF,0xDF,0xFC,0xFC,0xCC,0xCC,0xCC,0xCC,0xFC,0xFC}, /*"금"*/
    {0x7E,0xE7,0xE7,0x7E,0x00,0xFF,0x18,0xFF,0x06,0x06,0x06,0x06,0x06,0x06,0xFE,0xFE}, /*"액"*/
    {0x07,0x07,0x07,0x07,0x07,0xFF,0xFF,0xFF,0xE0,0xE0,0xE0,0xE0,0xE0,0xFF,0xFF,0xFF} /*"]"*/
};

unsigned char font_register[6][16] =
{
    {0xFF,0xFF,0xFF,0x07,0x07,0x07,0x07,0x07,0xFF,0xFF,0xFF,0xE0,0xE0,0xE0,0xE0,0xE0},  /*"["*/
    {0x7,0xff,0xff,0x7,0xf0,0xff,0x0,0xff,0xfe,0x1f,0x1f,0xfe,0x1,0xff,0x0,0xff},       /*"제"*/
    {0x33,0x3f,0x3f,0x33,0x33,0x3f,0x3f,0x33,0xfb,0xfb,0xfb,0xdf,0xdf,0xfb,0xfb,0xfb},  /*"품"*/
    {0x3f,0x3f,0x33,0x33,0x33,0x33,0x33,0x33,0x73,0xfb,0xfb,0xdb,0xdb,0xfb,0xfb,0x73},  /*"등"*/
    {0xfb,0xfb,0xdb,0xdb,0xdb,0xdb,0xdf,0xdf,0x36,0x36,0x36,0x37,0x37,0x36,0xf6,0xf6},  /*"록"*/
    {0x07,0x07,0x07,0x07,0x07,0xFF,0xFF,0xFF,0xE0,0xE0,0xE0,0xE0,0xE0,0xFF,0xFF,0xFF}   /*"]"*/
};

unsigned char font_success[3][16] =
{
    {0xf8,0xff,0x7,0xff,0xf8,0x70,0xff,0xff,0x31,0x79,0xfc,0xcd,0xcd,0xfc,0x79,0x31},  /*"성"*/
    {0x83,0x83,0xfb,0xfb,0x83,0x83,0xbf,0xbf,0x31,0x79,0xfd,0xcd,0xcd,0xfd,0x79,0x31}, /*"공"*/
    {0xfc,0xfe,0xfc,0xf8,0xfc,0xfe,0xfc,0x0,0x3,0xf,0x3f,0x7f,0x3f,0xf,0x3,0x0}        /* 하트모양 */
};

unsigned char font_fail[4][16] =
{
    {0x7c,0x7f,0x7,0x7f,0x7c,0x0,0x7f,0x7f,0xfb,0xfb,0xdb,0xdb,0xdb,0xdb,0xdf,0xdf},   /*"실"*/
    {0x1e,0xfe,0x1e,0xfe,0x1e,0xff,0xe0,0xff,0x78,0x7f,0x78,0x7f,0x78,0xff,0x7,0xff},  /*"패"*/
    {0x0,0x6,0x6,0xfe,0xfe,0x6,0x6,0x0,0x0,0x0,0x0,0x7f,0x7f,0x0,0x0,0x0},             /*ㅜ*/
    {0x0,0x6,0x6,0xfe,0xfe,0x6,0x6,0x0,0x0,0x0,0x0,0x7f,0x7f,0x0,0x0,0x0}              /*ㅜ*/
};


unsigned char font_money[6][16] =
{
    {0xFF,0xFF,0xFF,0x07,0x07,0x07,0x07,0x07,0xFF,0xFF,0xFF,0xE0,0xE0,0xE0,0xE0,0xE0}, /*"["*/
    {0x03,0xff,0xff,0xff,0x03,0xC0,0xff,0xff,0x30,0x3F,0x0F,0x3F,0x30,0x01,0x7F,0x7F}, /*"저"*/
    {0x66,0x66,0x7E,0x3f,0x3f,0x7E,0x66,0x66,0x1B,0x1B,0x1B,0x1f,0x1f,0x1B,0xFB,0xFB}, /*"축"*/
    {0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xDF,0xDF,0xFC,0xFC,0xCC,0xCC,0xCC,0xCC,0xFC,0xFC}, /*"금"*/
    {0x7E,0xE7,0xE7,0x7E,0x00,0xFF,0x18,0xFF,0x06,0x06,0x06,0x06,0x06,0x06,0xFE,0xFE}, /*"액"*/
    {0x07,0x07,0x07,0x07,0x07,0xFF,0xFF,0xFF,0xE0,0xE0,0xE0,0xE0,0xE0,0xFF,0xFF,0xFF} /*"]"*/
};

unsigned char font_num[12][16] =
{
    {0xFE,0xFF,0xFF,0x1F,0x1F,0xFF,0xFF,0xFE,0x7F,0xFF,0xFF,0xF8,0xF8,0xFF,0xFF,0x7F}, /*숫자0*/
    {0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00}, /*숫자1*/
    {0xCF,0xCF,0xCF,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF3,0xF3,0xF3,0xF3}, /*숫자2*/
    {0xCF,0xCF,0xCF,0xCF,0xFF,0xFF,0xFF,0xFF,0xF3,0xF3,0xF3,0xF3,0xFF,0xFF,0xFF,0xFF}, /*숫자3*/
    {0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x07,0x07,0x07,0x07,0xFF,0xFF,0xFF,0x07}, /*숫자4*/
    {0xFF,0xFF,0xFF,0xFF,0xCF,0xCF,0xCF,0xCF,0xF3,0xF3,0xF3,0xF3,0xFF,0xFF,0xFF,0xFF}, /*숫자5*/
    {0xFF,0xFF,0xFF,0xFF,0xC0,0xC0,0xC0,0xC0,0xFF,0xFF,0xFF,0xE1,0xE1,0xFF,0xFF,0xFF}, /*숫자6*/
    {0x0F,0x0F,0x0F,0x0F,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF}, /*숫자7*/
    {0xFE,0xFF,0xFF,0xC7,0xC7,0xFF,0xFF,0xFE,0x7F,0xFF,0xFF,0xE3,0xE3,0xFF,0xFF,0x7F}, /*숫자8*/
    {0xFF,0xFF,0xFF,0xC7,0xC7,0xFF,0xFF,0xFF,0x01,0x01,0x01,0x01,0x01,0xFF,0xFF,0xFF}, /*숫자9*/
    {0x7E,0xE7,0xE7,0x7E,0x00,0x30,0xFF,0xFF,0xE6,0xEE,0xCE,0xCE,0xC6,0xC0,0xCF,0xCF},  /*"원"*/
    {0x0,0x0,0x7c,0x7c,0x7c,0x7c,0x0,0x0,0x0,0x0,0x3e,0x3e,0x3e,0x3e,0x0,0x0        } /*":"*/
};

unsigned char font_game[6][16] =
{

    {0xFF,0xFF,0xFF,0x07,0x07,0x07,0x07,0x07,0xFF,0xFF,0xFF,0xE0,0xE0,0xE0,0xE0,0xE0}, /*"["*/
    {0x3,0x3,0xff,0xff,0xc0,0xff,0x0,0xff,0x0,0x0,0xff,0xff,0x1,0xff,0x0,0xff},        /*"게"*/
    {0x7e,0xff,0xe7,0xff,0x7e,0x0,0xff,0xff,0xf8,0xf8,0xd8,0xd8,0xd8,0xd8,0xfb,0xfb},  /*"임"*/
    {0x0,0xff,0xff,0xff,0x0,0x0,0xff,0xff,0xff,0xff,0x1,0xff,0xff,0x0,0xff,0xff},      /*"시"*/
    {0xe3,0xff,0xff,0xe3,0x0,0xff,0xff,0x30,0x1b,0x18,0x18,0x1b,0x18,0xfb,0xfb,0x0},   /*"작"*/
    {0x07,0x07,0x07,0x07,0x07,0xFF,0xFF,0xFF,0xE0,0xE0,0xE0,0xE0,0xE0,0xFF,0xFF,0xFF}  /*"]"*/
};

void init_SPI_master(void)
{
    SPI_DDR |= ((1 << SS) | (1 << SCK) | (1 << MOSI) | (1<<DC)|(1<<RST));
    SPI_PORT|= (1 << SS)|(1<<RST);
    SPCR     = ((1 << SPE)|(1 << MSTR)|(1 << SPR0)|(0<<SPR1)); // 16M/16=1Mhz

}

void write_oled(unsigned char data)
{
    SPI_PORT &=~(1<<SS);
    SPI_PORT &=~(1<<DC);
    SPDR = data;
    
    while(!(SPSR&(1<<SPIF)));
    SPI_PORT|=(1<<SS);
}

void write_oled_data(unsigned char data)
{
    SPI_PORT &=~(1<<SS);
    SPI_PORT |= (1<<DC);
    SPDR = data;
    
    while(!(SPSR&(1<<SPIF)));
    SPI_PORT|=(1<<SS);
    SPI_PORT &=~(1<<DC);
}

void clear_oled(void)
{
    draw_data(128,64,0,0,0x00);
}

void draw_char(int w, int h, int x, int y, char *data)
{
	/*
	 * w : 그려질 글자의 width
	 * h : 그려질 글자의 height
	 * x : 그려질 글자의 시작 x 좌표 (0~128)
	 * y : 그려질 글자의 시작 y 좌표 (0~7)
	 * data : 그려질 데이터 배열
	 */
	
	unsigned char i,j;
	unsigned char idx	= 0 ;
	unsigned height		= h/8; 	    //OLED는 한 페이지당 8픽셀을 차지
	unsigned startY		= CHANGE_PAGE + y; //0xB0은 OLED의 어떤 페이지를 선택하는지에대한 명령어이다
	unsigned startX     = x+5;	    //+1을하는 이유는 가독성을 높이기 위해서이다(이전글자로부터1픽셀 띄어서 )
	unsigned endX		= startX + w;
    

	for( i=0;i<height;i++ )
	{
		write_oled(startY+i);
		write_oled(CHANGE_COLUM);
		write_oled(startX);
		write_oled(endX);

		for( j=0;j<w;j++ )
		{
			write_oled_data(data[idx++]);
			_delay_us(100);
		}
	}
}

void clear_partial(int w, int h, int x, int y)
{
    /*
     * w : 클리어될 글자의 width
     * h : 클리어될 글자의 height
     * x : 클리어될 글자의 시작 x 좌표 (0~128)
     * y : 클리어될 글자의 시작 y 좌표 (0~7)
     */
    
    unsigned char i,j;
    unsigned char height		= h/8; 	    //OLED는 한 페이지당 8픽셀을 차지
    unsigned char startY		= CHANGE_PAGE + y; //0xB0은 OLED의 어떤 페이지를 선택하는지에대한 명령어이다
    unsigned char startX     = x+5;	    //+1을하는 이유는 가독성을 높이기 위해서이다(이전글자로부터1픽셀 띄어서 )
    unsigned char endX		= startX + w;
    
    for( i=0;i<height;i++ )
    {
        write_oled(startY+i);
        write_oled(CHANGE_COLUM);
        write_oled(startX);
        write_oled(endX-1);
        
        for(j=0;j<w;j++)
        {	
            write_oled_data(0x00);
            _delay_us(100);
        }
    }
}

void draw_data(int w, int h, int x, int y, char data)
{
	/*
	 * w : 그려질 글자의 width
	 * h : 그려질 글자의 height
	 * x : 그려질 글자의 시작 x 좌표 (0~128)
	 * y : 그려질 글자의 시작 y 좌표 (0~7)
	 * data : 그려질 데이터
	 */
	
	unsigned char i,j;
	unsigned height		= h/8; 	    //OLED는 한 페이지당 8픽셀을 차지
	unsigned startY		= CHANGE_PAGE + y; //0xB0은 OLED의 어떤 페이지를 선택하는지에대한 명령어이다
	unsigned startX     = x;	    //+1을하는 이유는 가독성을 높이기 위해서이다(이전글자로부터1픽셀 띄어서 )
	unsigned endX		= startX + w;
    
	for( i=0;i<height;i++ )
	{
		write_oled(startY+i);
		write_oled(CHANGE_COLUM);
		write_oled(startX);
		write_oled(endX-1);
        
		for(j=0;j<w;j++)
		{	
			write_oled_data(data);
			_delay_us(100);
		}
	}
}

void write_num_to_oled(unsigned long current_money)
{
	unsigned char curr_coin[10];
	unsigned char position 	= 0;
	unsigned long cu_co	= 0;
		
	unsigned char i      = 0;
	unsigned char startX = 0;

	cu_co = current_money;
	while(1)
	{
		curr_coin[position++] = cu_co%10;
		cu_co = cu_co/10;

        _delay_ms(2);
		if(cu_co == 0)
			break;
	}

	startX = (110 - ((position+1) * 8))/2 ; // 출력할 숫자를 가운데 정렬하기위한
    
    if(current_money==0)
        draw_data(100,16,5,5,0x00);
        
    else
        draw_data(120,16,4,5,0x00);
//        draw_data(8*(position+1),16,startX,5,0x00); // 그려진부분에 겹처서 그리는것을 방지하기위해 그리고자하는 부분에 그려져있던것을 클리어

	for( position = position-1 ; position > 0 ; position-- )
   		draw_char(8,16,startX+(i++*10),5,font_num[curr_coin[position]]);
	
   	draw_char(8,16,startX+(i++*10),5,font_num[curr_coin[0]]);
   	draw_char(8,16,startX+(i++*10),5,font_num[10]); //글자 "원"출력
}

void init_oled(void)
{
    init_SPI_master(); //init SPI
    
    write_oled(0xAE); //display off
    write_oled(0x20); //Set Memory Addressing Mode
    write_oled(0x02); //00);Horizontal Addressing Mode;01);Vertical Addressing Mode;10);Page Addressing Mode (RESET);11);Invalid
    write_oled(CHANGE_PAGE); //Set Page Start Address for Page Addressing Mode);0-7
    write_oled(0xc8); //Set COM Output Scan Direction
    write_oled(0x00); //---set low column address
    write_oled(0x10); //---set high column address
    write_oled(0x40); //--set start line address
    write_oled(0x81); //--set contrast control register
    write_oled(0x7f);
    write_oled(0xa1); //--set segment re-map 0 to 127
    write_oled(0xa8); //--set multiplex ratio(1 to 64)
    write_oled(0x3F);
    write_oled(0xa4); //0xa4);Output follows RAM content;0xa5);Output ignores RAM content
    write_oled(0xd3); //-set display offset
    write_oled(0x00); //-not offset
    write_oled(0xd5); //--set display clock divide ratio/oscillator frequency
    write_oled(0xf0); //--set divide ratio
    write_oled(0xd9); //--set pre-charge period
    write_oled(0x22); //
    write_oled(0xda); //--set com pins hardware configuration
    write_oled(0x12);
    write_oled(0xdb); //--set vcomh
    write_oled(0x20); //0x20);0.77xVcc
    write_oled(0x8d); //--set DC-DC enable
    write_oled(0x14); //
    write_oled(0xa6); //--set normal display  // a7 - inverse
    write_oled(0xaf); //--turn on oled panel
    
    clear_oled(); // 화면 클리어
}

void draw_percentage(unsigned char percent)
{
    
    draw_data(percent,8,7,0,0xCf);
    draw_data(percent,8,7,1,0xf3);
}


void draw_edge(unsigned char ispercent)
{
    draw_data(128,8,0,0,0x0f);
    if(ispercent)
    {
        draw_data(128,8,0,1,0xf0);
        draw_data(26,8,4,2,0x0f);
        draw_data(26,8,98,2,0x0f);
    }
    draw_data(4, 64,0,0,0xff);
    draw_data(4, 64,124,0,0xff);
    draw_data(120,8,4,8,0xf0);
}
